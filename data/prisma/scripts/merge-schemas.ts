import fs from 'fs/promises';
import path from 'path';
import { glob } from 'glob';
import { fileURLToPath } from 'url';

// --- Configuration ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const prismaDir = path.resolve(__dirname, '..'); // prisma directory
const baseSchemaPath = path.join(prismaDir, 'schemas', 'schema.base.prisma');
const generatedDir = path.join(prismaDir, 'schemas', 'generated');
const mergedSchemaPath = path.join(prismaDir, 'schemas', 'schema.merged.prisma');

// --- Helper Functions ---
async function readBaseSchema(): Promise<string> {
  try {
    const content = await fs.readFile(baseSchemaPath, 'utf-8');
    console.log(`‚úÖ Read base schema: ${path.basename(baseSchemaPath)}`);
    return content;
  } catch (error) {
    console.error(`‚ùå Error reading base schema:`, error);
    throw error;
  }
}

async function findGeneratedSchemas(): Promise<string[]> {
  try {
    const schemaFiles = await glob(`${generatedDir}/*.prisma`);
    console.log(`Found ${schemaFiles.length} generated schema files:`);
    schemaFiles.forEach(file => console.log(`  - ${path.basename(file)}`));
    return schemaFiles;
  } catch (error) {
    console.error('Error finding generated schemas:', error);
    return [];
  }
}

async function readGeneratedSchema(filePath: string): Promise<string> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    console.log(`‚úÖ Read generated schema: ${path.basename(filePath)}`);
    return content;
  } catch (error) {
    console.error(`‚ùå Error reading generated schema ${filePath}:`, error);
    return '';
  }
}

function extractModelsFromSchema(content: string): string {
  // Remove generator and datasource blocks, keep only models
  const lines = content.split('\n');
  const modelLines: string[] = [];
  let inModel = false;
  let inGeneratorOrDatasource = false;
  let braceCount = 0;

  for (const line of lines) {
    const trimmedLine = line.trim();
    
    // Skip empty lines and comments at the top
    if (!trimmedLine || trimmedLine.startsWith('//')) {
      if (inModel) {
        modelLines.push(line);
      }
      continue;
    }
    
    // Detect generator or datasource blocks
    if (trimmedLine.startsWith('generator ') || trimmedLine.startsWith('datasource ')) {
      inGeneratorOrDatasource = true;
      braceCount = 0;
      continue;
    }
    
    // Handle braces in generator/datasource blocks
    if (inGeneratorOrDatasource) {
      if (trimmedLine.includes('{')) braceCount++;
      if (trimmedLine.includes('}')) braceCount--;
      
      if (braceCount <= 0) {
        inGeneratorOrDatasource = false;
      }
      continue;
    }
    
    // Detect model blocks
    if (trimmedLine.startsWith('model ')) {
      inModel = true;
      modelLines.push(line);
      continue;
    }
    
    // Handle model content
    if (inModel) {
      modelLines.push(line);
      
      // Check if model block ends
      if (trimmedLine === '}') {
        inModel = false;
        modelLines.push(''); // Add blank line after model
      }
    }
  }
  
  return modelLines.join('\n');
}

function generateMergedSchema(baseContent: string, generatedContents: string[]): string {
  let mergedSchema = baseContent;
  
  // Add header comment
  const header = `
// =============================================================================
// MERGED PRISMA SCHEMA
// =============================================================================
// This file is auto-generated from:
// - Base schema: schema.base.prisma
// - Generated schemas: generated/*.prisma
//
// ‚ö†Ô∏è  DO NOT EDIT THIS FILE MANUALLY!
// ‚ö†Ô∏è  It will be overwritten during the build process.
// =============================================================================

`;
  
  mergedSchema = header + mergedSchema;
  
  // Add generated models section
  if (generatedContents.length > 0) {
    mergedSchema += '\n\n// =============================================================================\n';
    mergedSchema += '// GENERATED MODELS FROM DSL\n';
    mergedSchema += '// =============================================================================\n\n';
    
    generatedContents.forEach((content, index) => {
      const models = extractModelsFromSchema(content);
      if (models.trim()) {
        mergedSchema += models + '\n';
      }
    });
  }
  
  return mergedSchema;
}

async function writeMergedSchema(content: string): Promise<void> {
  try {
    await fs.writeFile(mergedSchemaPath, content, 'utf-8');
    console.log(`‚úÖ Generated merged schema: ${path.basename(mergedSchemaPath)}`);
  } catch (error) {
    console.error(`‚ùå Error writing merged schema:`, error);
    throw error;
  }
}

async function ensureGeneratedDirectory(): Promise<void> {
  try {
    await fs.mkdir(generatedDir, { recursive: true });
    console.log(`‚úÖ Ensured generated directory exists: ${generatedDir}`);
  } catch (error) {
    console.error('‚ùå Error creating generated directory:', error);
    throw error;
  }
}

// --- Main Logic ---
async function mergeSchemas(): Promise<void> {
  console.log('üîß Starting Prisma schema merge process...');
  
  await ensureGeneratedDirectory();
  
  // Read base schema
  const baseContent = await readBaseSchema();
  
  // Find and read generated schemas
  const generatedFiles = await findGeneratedSchemas();
  const generatedContents: string[] = [];
  
  for (const filePath of generatedFiles) {
    const content = await readGeneratedSchema(filePath);
    if (content.trim()) {
      generatedContents.push(content);
    }
  }
  
  // Generate merged schema
  console.log(`Merging base schema with ${generatedContents.length} generated schemas...`);
  const mergedContent = generateMergedSchema(baseContent, generatedContents);
  
  // Write merged schema
  await writeMergedSchema(mergedContent);
  
  console.log(`üéØ Successfully merged ${generatedContents.length + 1} schema files into ${path.basename(mergedSchemaPath)}`);
}

mergeSchemas().catch(error => {
  console.error('‚ùå Schema merge process failed:', error);
  process.exit(1);
});
