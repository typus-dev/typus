#!/bin/bash

# =============================================================================
# Typus LITE - Safe Update Script
# =============================================================================
# Usage: ./update.sh [--fresh] [--help]
#
# Options:
#   --fresh    Clean install with database reset (DESTRUCTIVE!)
#              Without this flag, only updates core, preserves everything
#   --help     Show this help and exit
#
# What it does:
#   1. Full backup of site directory (excluding storage/uploads)
#   2. Backup database
#   3. Copy @typus-core/ from release (overwrite)
#   4. Update typus-manifest.json
#   5. Create .env.update / docker-compose.yml.update if configs differ
#   6. Rebuild container
#
# What is preserved:
#   - plugins/
#   - custom/
#   - storage/
#   - scripts/
#   - .env
#   - docker-compose.yml
#   - All other local files
# =============================================================================

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# Parse arguments
FRESH_INSTALL=false
SHOW_HELP=false

print_help() {
    sed -n '1,80p' "$0"
    echo ""
    echo "Examples:"
    echo "  ./setup/update.sh"
    echo "  ./setup/update.sh --fresh"
}

for arg in "$@"; do
    case "$arg" in
        --fresh)
            FRESH_INSTALL=true
            ;;
        -h|--help)
            SHOW_HELP=true
            ;;
        "")
            ;;
        -*)
            echo -e "${RED}âŒ Unknown option: ${arg}${NC}"
            echo ""
            print_help
            exit 1
            ;;
        *)
            echo -e "${RED}âŒ Unexpected argument: ${arg}${NC}"
            echo ""
            print_help
            exit 1
            ;;
    esac
done

if [ "$SHOW_HELP" = true ]; then
    print_help
    exit 0
fi

# Auto-detect installation directory (where this script is run from)
INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ "$(basename "$INSTALL_DIR")" = "setup" ]; then
    INSTALL_DIR="$(dirname "$INSTALL_DIR")"
fi

BACKUP_DIR="$INSTALL_DIR/storage/backups"
TYPUS_ROOT_DIR=""

# Try to auto-detect "host root" (where release-system/releases exists).
# This supports layouts like:
#   <typus-root>/test-installations/<domain>
#   <typus-root>/<domain>
detect_typus_root() {
    local dir="$INSTALL_DIR"
    while [ -n "$dir" ] && [ "$dir" != "/" ]; do
        if [ -d "$dir/release-system/releases" ]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

TYPUS_ROOT_DIR="$(detect_typus_root 2>/dev/null || true)"

rm_rf_with_docker_fallback() {
    local path="$1"
    local base_name
    base_name="$(basename "$path")"

    rm -rf "$path" 2>/dev/null || true
    if [ ! -e "$path" ]; then
        return 0
    fi

    if command -v docker >/dev/null 2>&1; then
        echo -e "${YELLOW}âš ï¸  Cannot remove ${base_name} due to permissions. Trying docker fallback...${NC}"
        docker run --rm -v "$INSTALL_DIR:/work" alpine:3.20 sh -lc "rm -rf \"/work/${base_name}\""
    fi

    if [ -e "$path" ]; then
        echo -e "${RED}âŒ Failed to remove $path (permissions).${NC}"
        echo -e "${YELLOW}Tip: stop containers and remove as root, or clear Vite caches (.vite) generated by docker dev mode.${NC}"
        exit 1
    fi
}

DEFAULT_RELEASE_DIR=""
if [ -n "$TYPUS_ROOT_DIR" ] && [ -d "$TYPUS_ROOT_DIR/release-system/releases" ]; then
    DEFAULT_RELEASE_DIR="$TYPUS_ROOT_DIR/release-system/releases"
fi

RELEASE_DIR="${TYPUS_RELEASE_DIR:-$DEFAULT_RELEASE_DIR}"
TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)

# Read database credentials from .env
if [ -f "$INSTALL_DIR/.env" ]; then
    source "$INSTALL_DIR/.env"
fi

# Support both old (DB_*) and new (DATABASE_*) variable names
DB_HOST="${DB_HOST:-${DATABASE_HOST:-common-mysql}}"
DB_PORT="${DB_PORT:-${DATABASE_PORT:-3306}}"
DB_NAME="${DB_NAME:-${DATABASE_NAME:-}}"
DB_USER="${DB_USER:-${DATABASE_USER:-root}}"
DB_PASSWORD="${DB_PASSWORD:-${DATABASE_PASSWORD:-}}"

# Get domain from .env or directory name
DOMAIN="${TYPUS_DOMAIN:-$(basename $INSTALL_DIR)}"

echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
if [ "$FRESH_INSTALL" = true ]; then
    echo -e "${RED}â•‘  Update Site (FRESH - DANGER!)         â•‘${NC}"
else
    echo -e "${BLUE}â•‘  Update Site (safe update)             â•‘${NC}"
fi
echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""
echo -e "${CYAN}Domain:${NC} $DOMAIN"
echo -e "${CYAN}Database:${NC} $DB_NAME @ $DB_HOST"
echo -e "${CYAN}Install Dir:${NC} $INSTALL_DIR"
echo ""

# Check if release exists
if [ -z "$RELEASE_DIR" ]; then
    echo -e "${RED}âŒ RELEASE_DIR not detected.${NC}"
    echo -e "${YELLOW}Set TYPUS_RELEASE_DIR=/path/to/releases or run from a host layout that contains release-system/releases.${NC}"
    exit 1
fi

LATEST_RELEASE=$(ls -t "$RELEASE_DIR"/lite-complete-*.tar.gz 2>/dev/null | head -1)
if [ -z "$LATEST_RELEASE" ]; then
    echo -e "${YELLOW}No release found. Building fresh release...${NC}"
    if [ -n "$TYPUS_ROOT_DIR" ] && [ -f "$TYPUS_ROOT_DIR/test-installations/1-make-release.sh" ]; then
        cd "$TYPUS_ROOT_DIR/test-installations"
        ./1-make-release.sh
        LATEST_RELEASE=$(ls -t "$RELEASE_DIR"/lite-complete-*.tar.gz 2>/dev/null | head -1)
    else
        echo -e "${RED}âŒ Cannot build release - script not found${NC}"
        exit 1
    fi
fi

echo -e "${BLUE}ğŸ“¦ Using release: $(basename $LATEST_RELEASE)${NC}"
echo ""

cd "$INSTALL_DIR"
mkdir -p "$BACKUP_DIR"

# =============================================================================
# STEP 1: Full backup of site directory (excluding uploads)
# =============================================================================
echo -e "${BLUE}ğŸ“¦ Backing up site directory...${NC}"
SITE_BACKUP="$BACKUP_DIR/site_${TIMESTAMP}.tar.gz"
tar -czf "$SITE_BACKUP" \
    --exclude='storage/uploads' \
    --exclude='storage/backups' \
    --exclude='storage/cache' \
    --exclude='storage/html-cache' \
    --exclude='storage/temp' \
    --exclude='storage/logs' \
    --exclude='node_modules' \
    -C "$(dirname $INSTALL_DIR)" \
    "$(basename $INSTALL_DIR)" 2>/dev/null || true
if [ -s "$SITE_BACKUP" ]; then
    SITE_BACKUP_SIZE=$(du -h "$SITE_BACKUP" | cut -f1)
    echo -e "${GREEN}âœ“ Site backed up: $(basename $SITE_BACKUP) ($SITE_BACKUP_SIZE)${NC}"
else
    echo -e "${YELLOW}âš ï¸  Site backup failed or empty${NC}"
fi

# =============================================================================
# STEP 2: Backup database
# =============================================================================
if [ -n "$DB_NAME" ] && [ -n "$DB_PASSWORD" ]; then
    echo -e "${BLUE}ğŸ“¦ Backing up database...${NC}"
    DB_BACKUP="$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}.sql.gz"
    # Avoid leaking password in process args: pass via stdin â†’ MYSQL_PWD inside container.
    docker exec -i "$DB_HOST" sh -c 'read -r MYSQL_PWD; export MYSQL_PWD; exec mysqldump -u "$1" "$2"' sh "$DB_USER" "$DB_NAME" 2>/dev/null \
      <<<"$DB_PASSWORD" | gzip > "$DB_BACKUP" || true
    if [ -s "$DB_BACKUP" ]; then
        DB_BACKUP_SIZE=$(du -h "$DB_BACKUP" | cut -f1)
        echo -e "${GREEN}âœ“ Database backed up: $(basename $DB_BACKUP) ($DB_BACKUP_SIZE)${NC}"
    else
        echo -e "${YELLOW}âš ï¸  No existing database to backup${NC}"
        rm -f "$DB_BACKUP"
    fi
else
    echo -e "${YELLOW}âš ï¸  Database credentials not found in .env, skipping DB backup${NC}"
fi

# =============================================================================
# FRESH INSTALL: Reset database (only with --fresh flag)
# =============================================================================
if [ "$FRESH_INSTALL" = true ]; then
    echo -e "${RED}âš ï¸  FRESH INSTALL: This will reset the database!${NC}"
    read -p "Are you sure? (yes/no): " CONFIRM
    if [ "$CONFIRM" != "yes" ]; then
        echo -e "${YELLOW}Aborted.${NC}"
        exit 1
    fi
    if [ -n "$DB_NAME" ] && [ -n "$DB_PASSWORD" ]; then
        # Avoid leaking password in process args: pass via stdin â†’ MYSQL_PWD inside container.
        SQL="DROP DATABASE IF EXISTS $DB_NAME; CREATE DATABASE $DB_NAME;"
        docker exec -i "$DB_HOST" sh -c 'read -r MYSQL_PWD; export MYSQL_PWD; exec mysql -u "$1" -e "$2"' sh "$DB_USER" "$SQL" 2>/dev/null \
          <<<"$DB_PASSWORD"
        echo -e "${GREEN}âœ“ Database reset${NC}"
    fi
fi

# =============================================================================
# STEP 3: Extract release to temp directory
# =============================================================================
echo -e "${BLUE}ğŸ“¦ Extracting release...${NC}"
TEMP_DIR=$(mktemp -d)
cleanup_temp_dir() {
    rm -rf "$TEMP_DIR"
}
trap cleanup_temp_dir EXIT
tar -xzf "$LATEST_RELEASE" -C "$TEMP_DIR"
echo -e "${GREEN}âœ“ Release extracted to temp${NC}"

# =============================================================================
# STEP 3.5: Update setup scripts (self-update for next runs)
# =============================================================================
echo -e "${BLUE}ğŸ”„ Updating setup scripts (install/update tools)...${NC}"
if [ -d "$TEMP_DIR/setup" ]; then
    mkdir -p "$INSTALL_DIR/setup"
    for f in update.sh install.sh manage-lite.sh quickstart.sh; do
        if [ -f "$TEMP_DIR/setup/$f" ]; then
            if [ -f "$INSTALL_DIR/setup/$f" ] && ! diff -q "$INSTALL_DIR/setup/$f" "$TEMP_DIR/setup/$f" >/dev/null 2>&1; then
                cp "$INSTALL_DIR/setup/$f" "$INSTALL_DIR/setup/$f.bak.$TIMESTAMP" 2>/dev/null || true
            fi
            cp "$TEMP_DIR/setup/$f" "$INSTALL_DIR/setup/$f"
            chmod +x "$INSTALL_DIR/setup/$f" 2>/dev/null || true
        fi
    done
    echo -e "${GREEN}âœ“ setup scripts updated${NC}"
else
    echo -e "${YELLOW}âš ï¸  setup/ not found in release, skipping${NC}"
fi

# =============================================================================
# STEP 4: Copy core files (overwrite)
# =============================================================================
echo -e "${BLUE}ğŸ”„ Updating @typus-core/...${NC}"
rm_rf_with_docker_fallback "$INSTALL_DIR/@typus-core"
cp -r "$TEMP_DIR/@typus-core" "$INSTALL_DIR/"
echo -e "${GREEN}âœ“ @typus-core/ updated${NC}"

echo -e "${BLUE}ğŸ”„ Updating typus-manifest.json...${NC}"
cp "$TEMP_DIR/typus-manifest.json" "$INSTALL_DIR/"
echo -e "${GREEN}âœ“ typus-manifest.json updated${NC}"

echo -e "${BLUE}ğŸ”„ Updating pnpm-lock.yaml...${NC}"
cp "$TEMP_DIR/pnpm-lock.yaml" "$INSTALL_DIR/"
echo -e "${GREEN}âœ“ pnpm-lock.yaml updated${NC}"

# Baseline defaults + seed scripts are part of core (should be kept in sync)
echo -e "${BLUE}ğŸ”„ Updating baseline seed scripts...${NC}"
if [ -d "$TEMP_DIR/data/baseline" ]; then
    rm_rf_with_docker_fallback "$INSTALL_DIR/data/baseline"
    mkdir -p "$INSTALL_DIR/data"
    cp -r "$TEMP_DIR/data/baseline" "$INSTALL_DIR/data/"
    echo -e "${GREEN}âœ“ data/baseline updated${NC}"
else
    echo -e "${YELLOW}âš ï¸  data/baseline not found in release, skipping${NC}"
fi

# Runtime files that must stay in sync with core (permissions, supervisord, entrypoint)
echo -e "${BLUE}ğŸ”„ Updating runtime (Dockerfile + docker configs/scripts)...${NC}"
if [ -f "$TEMP_DIR/Dockerfile.prod" ]; then
    cp "$TEMP_DIR/Dockerfile.prod" "$INSTALL_DIR/"
fi
mkdir -p "$INSTALL_DIR/docker/configs" "$INSTALL_DIR/docker/scripts"
if [ -f "$TEMP_DIR/docker/configs/supervisord.conf" ]; then
    cp "$TEMP_DIR/docker/configs/supervisord.conf" "$INSTALL_DIR/docker/configs/"
fi
if [ -f "$TEMP_DIR/docker/scripts/entrypoint.sh" ]; then
    cp "$TEMP_DIR/docker/scripts/entrypoint.sh" "$INSTALL_DIR/docker/scripts/"
    chmod +x "$INSTALL_DIR/docker/scripts/entrypoint.sh" 2>/dev/null || true
fi
echo -e "${GREEN}âœ“ Runtime updated${NC}"

# =============================================================================
# STEP 5: Check config files (create .update if different)
# =============================================================================
echo -e "${BLUE}ğŸ” Checking config files...${NC}"

# Check .env
if [ -f "$INSTALL_DIR/.env" ] && [ -f "$TEMP_DIR/.env.example" ]; then
    if ! diff -q "$INSTALL_DIR/.env" "$TEMP_DIR/.env.example" > /dev/null 2>&1; then
        cp "$TEMP_DIR/.env.example" "$INSTALL_DIR/.env.update"
        echo -e "${YELLOW}âš ï¸  .env differs - created .env.update for review${NC}"
    else
        echo -e "${GREEN}âœ“ .env unchanged${NC}"
    fi
elif [ ! -f "$INSTALL_DIR/.env" ]; then
    cp "$TEMP_DIR/.env.example" "$INSTALL_DIR/.env"
    echo -e "${GREEN}âœ“ .env created from template${NC}"
fi

# Check docker-compose.yml
if [ -f "$INSTALL_DIR/docker-compose.yml" ] && [ -f "$TEMP_DIR/docker-compose.yml" ]; then
    if ! diff -q "$INSTALL_DIR/docker-compose.yml" "$TEMP_DIR/docker-compose.yml" > /dev/null 2>&1; then
        cp "$TEMP_DIR/docker-compose.yml" "$INSTALL_DIR/docker-compose.yml.update"
        echo -e "${YELLOW}âš ï¸  docker-compose.yml differs - created docker-compose.yml.update for review${NC}"
    else
        echo -e "${GREEN}âœ“ docker-compose.yml unchanged${NC}"
    fi
elif [ ! -f "$INSTALL_DIR/docker-compose.yml" ]; then
    cp "$TEMP_DIR/docker-compose.yml" "$INSTALL_DIR/docker-compose.yml"
    echo -e "${GREEN}âœ“ docker-compose.yml created${NC}"
fi

# =============================================================================
# STEP 6: Cleanup temp
# =============================================================================
rm -rf "$TEMP_DIR"

# =============================================================================
# STEP 7: Stop and rebuild container
# =============================================================================
echo -e "${BLUE}ğŸ³ Rebuilding container...${NC}"
docker compose down 2>/dev/null || true
docker compose up -d --build
echo -e "${GREEN}âœ“ Container rebuilt${NC}"

# =============================================================================
# DONE
# =============================================================================
echo ""
echo -e "${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
echo -e "${GREEN}â•‘  âœ“ Site Updated!                       â•‘${NC}"
echo -e "${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""

echo -e "${CYAN}Backups created:${NC}"
[ -f "$SITE_BACKUP" ] && echo -e "  Site: $SITE_BACKUP"
[ -f "$DB_BACKUP" ] && echo -e "  DB:   $DB_BACKUP"
echo ""

# Check for .update files
if [ -f "$INSTALL_DIR/.env.update" ] || [ -f "$INSTALL_DIR/docker-compose.yml.update" ]; then
    echo -e "${YELLOW}âš ï¸  Review these files for config changes:${NC}"
    [ -f "$INSTALL_DIR/.env.update" ] && echo -e "  - .env.update"
    [ -f "$INSTALL_DIR/docker-compose.yml.update" ] && echo -e "  - docker-compose.yml.update"
    echo ""
fi

# Show version
if [ -f "$INSTALL_DIR/typus-manifest.json" ]; then
    VERSION=$(grep -o '"version": "[^"]*"' "$INSTALL_DIR/typus-manifest.json" | cut -d'"' -f4)
    echo -e "${CYAN}Version:${NC} $VERSION"
fi

echo ""
echo -e "${CYAN}Container status:${NC}"
docker compose ps
echo ""

echo -e "${CYAN}To restore from backup:${NC}"
[ -f "$SITE_BACKUP" ] && echo -e "  tar -xzf $SITE_BACKUP -C $(dirname $INSTALL_DIR)/"
echo ""
