import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { DslModel, DslField } from '../types.js';
import { registry } from '../registry.js';

/**
 * Generate TypeScript interfaces from DSL models
 */
export class InterfaceGenerator {
  /**
   * Generate TypeScript interfaces
   */
  generate(): void {
    console.debug('[InterfaceGenerator] Generating TypeScript interfaces');
    
    // Get all models
    const models = registry.getAllModels();
    if (models.length === 0) {
      console.warn('[InterfaceGenerator] No models found in registry');
      return;
    }

    console.log(`[InterfaceGenerator] Found ${models.length} models:`, models.map(m => m.name));

    // Ensure types directory exists
    this.ensureTypesDirectory();

    // Generate individual interface files
    this.generateIndividualFiles(models);

    // Generate main auto-interfaces file (ONLY interfaces, no DSL client types)
    this.generateMainInterfacesFile(models);

    console.log('[InterfaceGenerator] âœ… Successfully generated interface files');
  }

  /**
   * Ensure types directory exists
   */
  private ensureTypesDirectory(): void {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const typesDir = join(__dirname, '..', 'types');
    
    if (!existsSync(typesDir)) {
      mkdirSync(typesDir, { recursive: true });
      console.debug('[InterfaceGenerator] Created types directory:', typesDir);
    }
  }

  /**
   * Generate individual interface files for each model
   */
  private generateIndividualFiles(models: DslModel[]): void {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const typesDir = join(__dirname, '..', 'types');
    const exportStatements: string[] = [];

    for (const model of models) {
      const fileName = `${model.name.toLowerCase()}.interface.ts`;
      const filePath = join(typesDir, fileName);
      
      let content = this.generateHeader();
      content += this.generateInterface(model) + '\n\n';
      content += this.generateFieldsNamespace(model) + '\n';
      
      writeFileSync(filePath, content, 'utf8');
      
      // Add to exports
      exportStatements.push(`export * from './${model.name.toLowerCase()}.interface.js';`);
      console.debug(`[InterfaceGenerator] Generated ${fileName}`);
    }

    // Generate index.ts file
    const indexPath = join(typesDir, 'index.ts');
    let indexContent = this.generateHeader();
    indexContent += exportStatements.join('\n') + '\n';
    writeFileSync(indexPath, indexContent, 'utf8');
    console.debug('[InterfaceGenerator] Generated types/index.ts');
  }

  /**
   * Generate main auto-interfaces file - ONLY interfaces, no frontend-specific code
   */
  private generateMainInterfacesFile(models: DslModel[]): void {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const autoInterfacesPath = join(__dirname, '..', 'auto-interfaces.ts');
    
    let content = this.generateHeader();
    
    // Import all types from types directory
    content += `export * from './types/index.js';\n\n`;
    
    // Generate combined interfaces for backward compatibility
    for (const model of models) {
      content += this.generateInterface(model) + '\n\n';
      content += this.generateFieldsNamespace(model) + '\n\n';
    }

    writeFileSync(autoInterfacesPath, content, 'utf8');
    console.debug('[InterfaceGenerator] Generated auto-interfaces.ts');
  }

  /**
   * Generate file header with timestamp
   */
  private generateHeader(): string {
    return `// THIS FILE IS AUTO-GENERATED. DO NOT EDIT DIRECTLY.
// Generated by DSL Generator on ${new Date().toISOString()}
`;
  }

  /**
   * Generate TypeScript interface for a model
   */
  private generateInterface(model: DslModel): string {
    let interfaceDef = `export interface I${model.name} {\n`;
    
    // Track which fields we've already added to prevent duplicates
    const addedFields = new Set<string>();

    // 1. Generate explicit fields first
    for (const field of model.fields) {
      if (!addedFields.has(field.name)) {
        interfaceDef += `  ${this.generateInterfaceField(field)};\n`;
        addedFields.add(field.name);
      } else {
        console.warn(`[InterfaceGenerator] Duplicate field '${field.name}' found in model ${model.name}, skipping explicit field definition`);
      }
    }

    // 2. Generate foreign key fields for belongsTo relations (only if not already present)
    if (model.relations) {
      for (const relation of model.relations) {
        if (relation.type === 'belongsTo') {
          const foreignKey = relation.foreignKey || `${relation.name}Id`;
          if (!addedFields.has(foreignKey)) {
            interfaceDef += `  ${foreignKey}: number${relation.required ? '' : ' | null'};\n`;
            addedFields.add(foreignKey);
          } else {
            console.warn(`[InterfaceGenerator] Foreign key '${foreignKey}' already exists in model ${model.name}, using explicit field definition`);
          }
        }
      }
    }

    // 3. Generate timestamps if enabled (only if not already present)
    if (model.config?.timestamps) {
      if (!addedFields.has('createdAt')) {
        interfaceDef += `  createdAt: Date;\n`;
        addedFields.add('createdAt');
      }
      if (!addedFields.has('updatedAt')) {
        interfaceDef += `  updatedAt: Date;\n`;
        addedFields.add('updatedAt');
      }
    }

    // 4. Generate soft delete if enabled (only if not already present)
    if (model.config?.softDelete) {
      if (!addedFields.has('deletedAt')) {
        interfaceDef += `  deletedAt?: Date | null;\n`;
        addedFields.add('deletedAt');
      }
    }

    // 5. Generate versioning if enabled (only if not already present)
    if (model.config?.versioning) {
      if (!addedFields.has('version')) {
        interfaceDef += `  version: number;\n`;
        addedFields.add('version');
      }
    }

    interfaceDef += `}`;
    return interfaceDef;
  }

  /**
   * Generate TypeScript field definition
   */
  private generateInterfaceField(field: DslField): string {
    const tsType = this.mapFieldType(field);
    return `${field.name}${field.required ? '' : '?'}: ${tsType}`;
  }

  /**
   * Generate namespace with field constants
   */
  private generateFieldsNamespace(model: DslModel): string {
    let namespaceDef = `export namespace ${model.name}Fields {\n`;
    
    // Track which field constants we've already added to prevent duplicates
    const addedConstants = new Set<string>();

    // 1. Generate constants for explicit fields first
    for (const field of model.fields) {
      if (!addedConstants.has(field.name)) {
        namespaceDef += `  export const ${field.name} = '${field.name}';\n`;
        addedConstants.add(field.name);
      }
    }

    // 2. Generate constants for foreign key fields (only if not already present)
    if (model.relations) {
      for (const relation of model.relations) {
        if (relation.type === 'belongsTo') {
          const foreignKey = relation.foreignKey || `${relation.name}Id`;
          if (!addedConstants.has(foreignKey)) {
            namespaceDef += `  export const ${foreignKey} = '${foreignKey}';\n`;
            addedConstants.add(foreignKey);
          }
        }
      }
    }

    // 3. Generate constants for timestamp fields (only if not already present)
    if (model.config?.timestamps) {
      if (!addedConstants.has('createdAt')) {
        namespaceDef += `  export const createdAt = 'createdAt';\n`;
        addedConstants.add('createdAt');
      }
      if (!addedConstants.has('updatedAt')) {
        namespaceDef += `  export const updatedAt = 'updatedAt';\n`;
        addedConstants.add('updatedAt');
      }
    }

    // 4. Generate constant for soft delete field (only if not already present)
    if (model.config?.softDelete) {
      if (!addedConstants.has('deletedAt')) {
        namespaceDef += `  export const deletedAt = 'deletedAt';\n`;
        addedConstants.add('deletedAt');
      }
    }

    // 5. Generate constant for version field (only if not already present)
    if (model.config?.versioning) {
      if (!addedConstants.has('version')) {
        namespaceDef += `  export const version = 'version';\n`;
        addedConstants.add('version');
      }
    }

    namespaceDef += `}`;
    return namespaceDef;
  }

  /**
   * Map DSL field type to TypeScript type
   */
  private mapFieldType(field: DslField): string {
    switch (field.type) {
      case 'string':
      case 'text':
        return 'string';
      case 'number':
        return 'number';
      case 'Int':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'date':
      case 'datetime':
        return 'Date';
      case 'json':
        return 'Record<string, any>';
      case 'enum':
        if (field.enumValues) {
          return field.enumValues.map((v: string) => `'${v}'`).join(' | ');
        } else if (field.enumName) {
          return field.enumName;
        } else {
          return 'string';
        }
      case 'object':
        return 'Record<string, any>';
      default:
        console.warn(`[InterfaceGenerator] Unknown field type: ${field.type} for field ${field.name}, using 'any'`);
        return 'any';
    }
  }
}

// Create and export a singleton instance
export const interfaceGenerator = new InterfaceGenerator();